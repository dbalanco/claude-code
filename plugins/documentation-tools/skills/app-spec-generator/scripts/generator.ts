/**
 * Document generator for creating app-specs.md
 */

import * as fs from 'fs';
import * as path from 'path';
import { FeatureData, GenerationResult } from './types';

/**
 * Generate the complete app-specs.md document
 */
export function generateAppSpecs(allFeatures: FeatureData[], stats: GenerationResult): string {
  const sections: string[] = [];

  // Header
  sections.push(generateHeader(stats));

  // Status Dashboard
  sections.push(generateStatusDashboard(allFeatures));

  // Table of Contents
  sections.push(generateTOC());

  // Overview
  sections.push(generateOverview());

  // Feature lists by status
  sections.push(generateFeatureList(allFeatures, 'completed'));
  sections.push(generateFeatureList(allFeatures, 'in_progress'));
  sections.push(generateFeatureList(allFeatures, 'planned'));

  // Technology Stack
  sections.push(generateTechStack());

  // Database Schema
  sections.push(generateDatabaseSchema());

  // Detailed Feature Specifications
  sections.push(generateFeatureDetails(allFeatures));

  // Footer
  sections.push(generateFooter());

  return sections.join('\n\n---\n\n');
}

/**
 * Generate header section
 */
function generateHeader(stats: GenerationResult): string {
  const date = new Date().toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  });

  return `# Perseon V2 - Application Specifications

> **Last Updated:** ${date}
> **Overall Completion:** ${stats.completionPercentage}% (${stats.completed} completed, ${stats.inProgress} in progress, ${stats.planned} planned)
> **Total Features:** ${stats.featuresCount}

*This document is auto-generated by the \`/update-specs\` command.*`;
}

/**
 * Generate table of contents
 */
function generateTOC(): string {
  return `## Table of Contents

1. [Overview](#overview)
2. [Implementation Status Dashboard](#-implementation-status-dashboard)
3. [Completed Features ‚úÖ](#-completed-features-)
4. [Features in Progress üü°](#-features-in-progress-)
5. [Planned Features ‚è≥](#-planned-features-)
6. [Technology Stack](#technology-stack)
7. [Database Schema](#database-schema)
8. [Detailed Feature Specifications](#detailed-feature-specifications)`;
}

/**
 * Generate overview section
 */
function generateOverview(): string {
  return `## Overview

**Perseon V2** is a comprehensive project management and GitHub integration platform designed to streamline development workflows. The application combines powerful project management capabilities with deep GitHub integration, community engagement features, and advanced analytics.

### Core Capabilities

- **GitHub Integration:** Seamless OAuth authentication, repository synchronization, webhook handling, and GitHub Actions automation
- **Project Management:** Kanban boards, issue tracking, sprint planning, and team collaboration tools
- **Community Features:** Feature request voting, bug report tracking, and community engagement
- **Analytics & Monitoring:** Real-time dashboards, performance metrics, and activity tracking
- **Workspace System:** Multi-tenant architecture with role-based access control

### Target Users

- **Development Teams:** Manage projects and collaborate effectively
- **Open Source Maintainers:** Engage with community and track contributions
- **Solo Developers:** Organize personal projects and track progress
- **Engineering Managers:** Monitor team performance and project health

### Tech Stack Highlights

- **Framework:** Next.js 15 with App Router, React 19, TypeScript
- **Database:** PostgreSQL with Prisma ORM
- **Authentication:** Better Auth with OAuth support
- **UI:** Shadcn UI components, Tailwind CSS, Radix UI primitives
- **Real-time:** WebSocket support for live updates`;
}

/**
 * Generate status dashboard
 */
function generateStatusDashboard(features: FeatureData[]): string {
  // Group by category
  const byCategory = new Map<string, FeatureData[]>();
  for (const feature of features) {
    const cat = feature.category;
    if (!byCategory.has(cat)) {
      byCategory.set(cat, []);
    }
    byCategory.get(cat)!.push(feature);
  }

  // Build table
  let table = `## üìä Implementation Status Dashboard\n\n`;
  table += `| Category | Progress | Completed | In Progress | Planned |\n`;
  table += `|----------|----------|-----------|-------------|---------|\n`;

  for (const [category, categoryFeatures] of byCategory) {
    const completed = categoryFeatures.filter(f => f.status === 'completed').length;
    const inProgress = categoryFeatures.filter(f => f.status === 'in_progress').length;
    const planned = categoryFeatures.filter(f => f.status === 'planned' || f.status === 'not_started').length;
    const total = categoryFeatures.length;

    const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;
    const progressBar = generateProgressBar(percentage);

    table += `| ${category} | ${progressBar} ${percentage}% | ${completed} | ${inProgress} | ${planned} |\n`;
  }

  return table;
}

/**
 * Generate ASCII progress bar
 */
function generateProgressBar(percentage: number): string {
  const barLength = 10;
  const filled = Math.round((percentage / 100) * barLength);
  const empty = barLength - filled;

  return '‚ñà'.repeat(filled) + '‚ñë'.repeat(empty);
}

/**
 * Generate feature list by status
 */
function generateFeatureList(features: FeatureData[], status: string): string {
  const filtered = features.filter(f => f.status === status);

  if (filtered.length === 0) {
    return '';
  }

  let section = '';

  if (status === 'completed') {
    section += `## ‚úÖ Completed Features (${filtered.length})\n\n`;
  } else if (status === 'in_progress') {
    section += `## üü° Features in Progress (${filtered.length})\n\n`;
  } else if (status === 'planned') {
    section += `## ‚è≥ Planned Features (${filtered.length})\n\n`;
  }

  // Group by category
  const byCategory = new Map<string, FeatureData[]>();
  for (const feature of filtered) {
    const cat = feature.category;
    if (!byCategory.has(cat)) {
      byCategory.set(cat, []);
    }
    byCategory.get(cat)!.push(feature);
  }

  for (const [category, categoryFeatures] of byCategory) {
    section += `### ${category}\n\n`;

    for (const feature of categoryFeatures) {
      const checkbox = status === 'completed' ? '[x]' : '[ ]';
      section += `- ${checkbox} **${feature.title}**\n`;

      if (feature.description) {
        section += `  - ${feature.description}\n`;
      }

      if (status === 'in_progress' && feature.completionPercentage > 0) {
        section += `  - Progress: ${feature.completionPercentage}% (${feature.tasksCompleted}/${feature.tasksTotal} tasks)\n`;
      }

      if (status === 'planned' && feature.effortEstimate) {
        section += `  - Estimated Effort: ${feature.effortEstimate}\n`;
      }

      if (feature.priority) {
        const priorityEmoji = feature.priority === 'critical' ? 'üî¥' :
                             feature.priority === 'high' ? 'üü†' :
                             feature.priority === 'medium' ? 'üü°' : 'üü¢';
        section += `  - Priority: ${priorityEmoji} ${feature.priority}\n`;
      }

      section += `  - [Implementation Plan](${feature.implementationPlanLink})\n`;
      section += `\n`;
    }
  }

  return section;
}

/**
 * Generate technology stack section
 */
function generateTechStack(): string {
  try {
    const packageJsonPath = path.join(process.cwd(), 'package.json');

    if (!fs.existsSync(packageJsonPath)) {
      return `## Technology Stack\n\n*Unable to load technology stack (package.json not found)*`;
    }

    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));
    const deps = packageJson.dependencies || {};
    const devDeps = packageJson.devDependencies || {};

    let section = `## Technology Stack\n\n`;

    // Core Framework
    section += `### Core Framework\n\n`;
    if (deps['next']) section += `- **Next.js** ${deps['next']} - React framework\n`;
    if (deps['react']) section += `- **React** ${deps['react']} - UI library\n`;
    if (devDeps['typescript']) section += `- **TypeScript** ${devDeps['typescript']} - Type safety\n`;

    // Backend & Database
    section += `\n### Backend & Database\n\n`;
    if (deps['@prisma/client']) section += `- **Prisma** ${deps['@prisma/client']} - ORM\n`;
    if (deps['postgresql'] || deps['pg']) section += `- **PostgreSQL** - Relational database\n`;

    // Authentication
    section += `\n### Authentication\n\n`;
    if (deps['better-auth']) section += `- **Better Auth** ${deps['better-auth']} - Authentication system\n`;

    // UI & Styling
    section += `\n### UI & Styling\n\n`;
    if (deps['tailwindcss'] || devDeps['tailwindcss']) section += `- **Tailwind CSS** - Utility-first CSS\n`;
    if (deps['@radix-ui/react-dialog']) section += `- **Radix UI** - Accessible UI primitives\n`;
    section += `- **Shadcn UI** - Component library\n`;

    // Other notable dependencies
    section += `\n### Other Key Dependencies\n\n`;
    const notable = ['zod', 'react-email', 'resend', '@octokit/rest'];
    for (const dep of notable) {
      if (deps[dep]) {
        section += `- **${dep}** ${deps[dep]}\n`;
      }
    }

    return section;
  } catch (error) {
    console.warn('‚ö†Ô∏è  Error generating tech stack:', error);
    return `## Technology Stack\n\n*Unable to load technology stack (error parsing package.json)*`;
  }
}

/**
 * Generate database schema section
 */
function generateDatabaseSchema(): string {
  try {
    const schemaPath = path.join(process.cwd(), 'prisma', 'schema.prisma');

    if (!fs.existsSync(schemaPath)) {
      return `## Database Schema\n\n*Unable to load database schema (prisma/schema.prisma not found)*`;
    }

    const schema = fs.readFileSync(schemaPath, 'utf-8');

    // Extract models
    const modelMatches = schema.matchAll(/model\s+(\w+)\s*\{([^}]+)\}/g);
    const models: { name: string; fields: string[] }[] = [];

    for (const match of modelMatches) {
      const modelName = match[1];
      const fieldsBlock = match[2];

      // Extract field names
      const fieldLines = fieldsBlock.split('\n').filter(line => line.trim() && !line.trim().startsWith('//'));
      const fields = fieldLines.map(line => {
        const fieldMatch = line.match(/^\s*(\w+)/);
        return fieldMatch ? fieldMatch[1] : null;
      }).filter(Boolean) as string[];

      models.push({ name: modelName, fields });
    }

    // Group by domain
    const domains = {
      'User Management': ['User', 'Session', 'Account', 'Verification'],
      'Workspace & Teams': ['Workspace', 'WorkspaceMember', 'WorkspaceInvitation'],
      'Projects & Issues': ['Project', 'Issue', 'IssueActivity', 'Sprint', 'Label'],
      'GitHub Integration': ['GitHubRepository', 'GitHubBranch', 'GitHubCommit', 'GitHubPullRequest', 'GitHubWebhook'],
      'Community Features': ['FeatureRequest', 'BugReport', 'Upvote', 'Comment'],
      'Activity & Notifications': ['Activity', 'Notification'],
    };

    let section = `## Database Schema\n\n`;
    section += `Total Models: ${models.length}\n\n`;

    for (const [domain, domainModels] of Object.entries(domains)) {
      const domainModelsList = models.filter(m => domainModels.includes(m.name));

      if (domainModelsList.length === 0) continue;

      section += `### ${domain}\n\n`;

      for (const model of domainModelsList) {
        section += `- **${model.name}** (${model.fields.length} fields)\n`;
      }

      section += `\n`;
    }

    // List remaining models
    const categorized = Object.values(domains).flat();
    const remaining = models.filter(m => !categorized.includes(m.name));

    if (remaining.length > 0) {
      section += `### Other Models\n\n`;
      for (const model of remaining) {
        section += `- **${model.name}** (${model.fields.length} fields)\n`;
      }
    }

    return section;
  } catch (error) {
    console.warn('‚ö†Ô∏è  Error generating database schema:', error);
    return `## Database Schema\n\n*Unable to load database schema (error parsing prisma/schema.prisma)*`;
  }
}

/**
 * Generate detailed feature specifications
 */
function generateFeatureDetails(features: FeatureData[]): string {
  let section = `## Detailed Feature Specifications\n\n`;

  // Group by category
  const byCategory = new Map<string, FeatureData[]>();
  for (const feature of features) {
    const cat = feature.category;
    if (!byCategory.has(cat)) {
      byCategory.set(cat, []);
    }
    byCategory.get(cat)!.push(feature);
  }

  let index = 1;
  for (const [category, categoryFeatures] of byCategory) {
    section += `### ${index}. ${category}\n\n`;

    for (const feature of categoryFeatures) {
      const statusEmoji = feature.status === 'completed' ? '‚úÖ' :
                         feature.status === 'in_progress' ? 'üü°' :
                         feature.status === 'planned' ? '‚è≥' : '‚ùå';

      section += `#### ${statusEmoji} ${feature.title}\n\n`;

      if (feature.description) {
        section += `${feature.description}\n\n`;
      }

      section += `**Status:** ${feature.status.replace('_', ' ')}\n\n`;

      if (feature.completionPercentage > 0) {
        section += `**Progress:** ${feature.completionPercentage}% (${feature.tasksCompleted}/${feature.tasksTotal} tasks)\n\n`;
      }

      if (feature.effortEstimate) {
        section += `**Effort Estimate:** ${feature.effortEstimate}\n\n`;
      }

      if (feature.targetDate) {
        section += `**Target Date:** ${feature.targetDate}\n\n`;
      }

      if (feature.priority) {
        section += `**Priority:** ${feature.priority}\n\n`;
      }

      section += `**Implementation Plan:** [View Details](${feature.implementationPlanLink})\n\n`;

      if (feature.features.length > 0) {
        section += `**Key Features:**\n\n`;
        for (const f of feature.features.slice(0, 5)) {
          section += `- ${f}\n`;
        }
        section += `\n`;
      }
    }

    index++;
  }

  return section;
}

/**
 * Generate footer
 */
function generateFooter(): string {
  const date = new Date().toISOString();
  return `## Document Information

**Generated:** ${date}
**Generator:** Documentation Generator System v1.0
**Command:** \`/update-specs\`

For questions or issues with this documentation system, see \`perseon/specs/doc-generator/README.md\`.`;
}

/**
 * Validate the generated app-specs.md file
 */
export function validateAppSpecs(filePath: string): boolean {
  try {
    if (!fs.existsSync(filePath)) {
      console.error('‚ùå app-specs.md does not exist');
      return false;
    }

    const content = fs.readFileSync(filePath, 'utf-8');

    if (content.length < 100) {
      console.error('‚ùå app-specs.md is too short (likely empty or corrupted)');
      return false;
    }

    // Check for expected sections
    const requiredSections = [
      '# Perseon V2',
      '## Overview',
      '## Technology Stack',
      '## Table of Contents',
    ];

    for (const section of requiredSections) {
      if (!content.includes(section)) {
        console.error(`‚ùå app-specs.md missing section: ${section}`);
        return false;
      }
    }

    console.log('‚úÖ app-specs.md validation passed');
    return true;
  } catch (error) {
    console.error('‚ùå Error validating app-specs.md:', error);
    return false;
  }
}
